diff --git a/esm/interface/getAutocompleteSuggestions.js b/esm/interface/getAutocompleteSuggestions.js
index ac159d132d095a789b966627d315f4238c79ab60..eea37ce47d3eee31a764719d269194e9bc6fc412 100644
--- a/esm/interface/getAutocompleteSuggestions.js
+++ b/esm/interface/getAutocompleteSuggestions.js
@@ -63,6 +63,9 @@ const hasTypeSystemDefinitions = (sdl) => {
     }
     return hasTypeSystemDef;
 };
+const primitives = new Set(['Int', 'Float', 'String', 'Boolean'])
+const edgeDirectives = new Set(['fold', 'recurse', 'optional', 'transform'])
+const propertyDirectives = new Set(['filter', 'tag', 'output', 'transform'])
 export function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
     var _a;
     const opts = Object.assign(Object.assign({}, options), { schema });
@@ -234,7 +237,23 @@ export function getAutocompleteSuggestions(schema, queryText, cursor, contextTok
         return getSuggestionsForVariableDefinition(token, schema, kind);
     }
     if (kind === RuleKinds.DIRECTIVE) {
-        return getSuggestionsForDirective(token, state, schema, kind);
+        // We should autocomplete fields on the line after we autocomplete a directive
+        if (state.needsAdvance || state.name === null) { // active after '@' or many other kinds of punctuation, so perfect for when we need to autocomplete directives.
+                                                         // `state` is `null` when the user autocompletes after typing just '@' then opening autocomplete menu
+            // further restrict the directives we suggest based on the type of the field we are on
+            // x.label does not include the '@'
+            let fieldType = typeInfo.fieldDef.type;
+            while (fieldType.ofType) {
+                fieldType = fieldType.ofType
+            }
+            if (primitives.has(fieldType.name)) {
+                return getSuggestionsForDirective(token, state, schema, kind).filter(x => propertyDirectives.has(x.label))
+            } else {
+                return getSuggestionsForDirective(token, state, schema, kind).filter(x => edgeDirectives.has(x.label))
+            }
+        } else { // there has been no '@' so we should autocomplete fields
+            return getSuggestionsForFieldNames(token, typeInfo, opts);
+        }
     }
     return [];
 }
@@ -442,7 +461,11 @@ function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind)
             const possibleIfaceMap = Object.create(null);
             for (const type of possibleObjTypes) {
                 for (const iface of type.getInterfaces()) {
-                    possibleIfaceMap[iface.name] = iface;
+                    // Only allow interfaces to be autocompleted that implement
+                    // the type of the fragment.
+                    if (iface._interfaces.some(iface => iface.name === typeInfo.parentType.name)) {
+                        possibleIfaceMap[iface.name] = iface;
+                    }
                 }
             }
             possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));
diff --git a/esm/interface/getDiagnostics.js b/esm/interface/getDiagnostics.js
index 38a10439b1a5d7e7adbdd3e16c743a9cedff9dab..c699c3166cf458a5f9e85a794591fd445e843821 100644
--- a/esm/interface/getDiagnostics.js
+++ b/esm/interface/getDiagnostics.js
@@ -90,7 +90,7 @@ export function getRange(location, queryText) {
     const lines = queryText.split('\n');
     invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');
     let stream = null;
-    for (let i = 0; i < location.line; i++) {
+    for (let i = 0; i <= location.line; i++) { // fix console error spam from hovering a comment on the first line of a file by properly visiting the first line of a file
         stream = new CharacterStream(lines[i]);
         while (!stream.eol()) {
             const style = parser.token(stream, state);
